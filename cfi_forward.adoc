[[forward]]
== Landing pad (Zicfilp)

To enforce forward-edge control-flow integrity, the Zicfilp extension introduces
a landing pad (`LPAD`) instruction. The `LPAD` instruction that must be placed
at the program locations that are valid targets of indirect jumps or calls. The
`LPAD` instruction (See <<LP_INST>>) is encoded using the `AUIPC` major opcode
with `rd=x0`.

Compilers emit a landing pad instruction as the first instruction of an
address-taken functions, as well as at any indirect jump targets. A landing pad
instruction is not required in functions that are only reached using a direct
call or direct jump.

The landing pad is designed to provide integrity to control transfers performed
using indirect call and jumps, and this is referred to as forward-edge
protection. When the Zicfilp is active, the hart tracks an expected landing pad
(`ELP`) state that is updated by an _indirect_call_ or _indirect_jump_ to
require a landing pad instruction at the target of the branch. If the
instruction at the target is not a landing pad, then a software check exception
is raised.

A landing pad may be optionally associated with a 20-bit label. With labeling
enabled, the number of landing pads that can be reached from an indirect call
or jump site can be defined using programming language-based policies. Labeling
of the landing pads enables software to achieve greater precision in pairing up
indirect call/jump sites with valid targets. When labeling of landing pads
is used, indirect call or indirect jump site can specify the expected label of
the landing pad and thereby constrain the set of landing pads that may be
reached from each indirect call or indirect jump site in the program.

In the simplest form, a program can be built with a single label value to
implement a coarse-grained version of forward-edge control-flow integrity. By
constraining gadgets to be preceded by a landing pad instruction that marks
the start of indirect callable functions, the program can significantly reduce
the available gadget space. A second form of label generation may generate a
signature, such as a MAC, using the prototype of the function. Programs that use
this approach would further constrain the gadgets accessible from a call site to
only indirect callable functions that match the prototype of the called
functions. Another approach to label generation involves analyzing the
control-flow-graph (CFG) of the program, which can lead to even more stringent
constraints on the set of reachable gadgets. Such programs may further use
multiple labels per function, which means that if a function is called from two
or more call sites, the functions can be labeled as reachable from each of the
call sites. For instance, consider two call sites A and B, where A calls the
functions X and Y, and B calls the functions Y and Z. In a single label scheme,
functions X, Y, and Z would need to be assigned the same label so that both call
sites A and B can invoke the common function Y. This scheme would allow call
site A to also call function Z and call site B to also call function X. However,
if function Y was assigned two labels - one corresponding to call site A and the
other to call site B, then Y can be invoked by both call sites, but X can only be
invoked by call site A and Z can only be invoked by call site B. To support
multiple labels, the compiler could generate a call-site-specific entry point
for shared functions, with each entry point having its own landing pad
instruction followed by a direct branch to the start of the function. This would
allow the function to be labeled with multiple labels, each corresponding to a
specific call site. A portion of the label space may be dedicated to labeled
landing pads that are only valid targets of an indirect jump (and not an
indirect call).

The `LPAD` instruction uses the code points defined as HINTs for the `AUIPC`
opcode. When Zicfilp is not active at a privilege level or when the extension
is not implemented, the landing pad instruction executes as a no-op. A program
that is built with `LPAD` instruction can thus continue to operate correctly,
but without forward-edge control-flow integrity, on processors that do not
support the Zicfilp extension or if the Zicfilp extension is not active.

Compilers and linkers should provided an attribute flag to indicate if the
program has been compiled with the Zicfilp extension and use that to determine
if the Zicfilp extension should be activated. The dynamic loader should activate
the use of Zicfilp extension for an application only if all executables (the
application and the dependent dynamically linked libraries) used by that
application use the Zicfiss extension.

When Zicfilp extension is not active or not implemented, that hart does not
required landing pad instructions at targets of indirect calls/jumps and the
landing instructions revert to being a no-op. This allows a program compiled
with landing pad instructions to operate correctly but without forward-edge
control-flow integrity.

The Zicfilp extensions may be activated for use individually and independently
for each privilege mode.

The Zicfilp extension depends on the Zicsr extension.

=== Landing pad enforceement

To enforce that the target of an indirect call or indirect jump must be a valid
landing pad instruction, the hart maintains an expected landing pad (`ELP`) state
to determine if a landing pad instruction is required at the target of an
indirect call or an indirect jump. The `ELP` state can be one of:

* 0 - `NO_LP_EXPECTED`
* 1 - `LP_EXPECTED`

The `ELP` state is initialized to `NO_LP_EXPECTED` by the hardware upon reset.

The Zicfilp extension, when enabled, determines if an indirect call or an
indirect jump must land on a landing pad, as specified in <<IND_CALL_JMP>>. If
`is_lp_expected` is 1, then the hart updates the `ELP` to `LP_EXPECTED`.

[[IND_CALL_JMP]]
.Landing pad expected determination
[listing]
----
  is_lp_expected = ( (JALR || C.JR || C.JALR) &&
                     (rs1 != x1) && (rs1 != x5) && (rs1 != x7) ) ? 1 : 0;
----

An indirect branch using `JALR`, `C.JALR`, or `C.JR` with `rs1` as `x7` is
termed a software guarded branch. Such branches do not need to land on a
`LPAD` instruction and thus do not set `ELP` to `LP_EXPECTED`.

[NOTE]
====
When the register source is a link register and the register destination is `x0`
then its a return from a procedure and does not require a landing pad at the
target.

When the register source and register destination are both link registers then
its a semantically-direct-call. For example, the `call offset` pseudoinstruction
may expand to a two instruction sequence composed of a `lui ra, imm20` or a
`auipc ra, imm20` instruction followed by a `jalr ra, imm12(ra)` instruction
where `ra` is the link register (either `x1` or `x5`). Since the address of the
procedure was not explicitly taken and the computed address is not obtained from
mutable memory, such semantically-direct calls do not require a landing pad to
be placed at the target. Compilers and JITers must only use the
semantically-direct calls only if when the `rs1` was computed as a PC-relative
or an absolute offset to the symbol.

The `tail offset` pseudoinstruction used to tail call a far-away procedure may
also be expanded to a two instruction sequence composed of a `lui x7, imm20` or
`auipc x7, imm20` followed by a `jalr x0, x7`. Since the address of the
procedure was not explicitly taken and the computed address is not obtained from
mutable memory, such semantically-direct tail-calls do not require a landing pad
to be placed at the target.

Software guarded branches may also be used by compilers to generate code for
constructs like switch-cases. When using the software guarded branches, the
compiler is required to ensure it has full control on the possible jump
targets (e.g., by obtaining the targets from a read-only table in memory and
performing bounds checking on the index into the table, etc.).
====

The landing pad may be labeled. Zicfilp extension designates the register `x7`
for use as the landing pad label register. To support labeled landing pads, the
indirect call/jump sites establish an expected landing pad label (e.g., using
the `lui` instruction) in the bits 31:12 of the `x7` register. The `LPAD`
instruction is encoded with a 20-bit immediate value called the landing-pad-label
(`LPL`) that is matched to the expected landing pad label. When `LPL` is encoded
as zero, the `LPAD` instruction does not perform the label check and in programs
built with this single label mode of operation the indirect call/jump sites do
not need to establish an expected landing pad label value in `x7`.

When `ELP` is set to `LP_EXPECTED`, if the next instruction in the instruction
stream is not 4-byte aligned, or is not `LPAD`, or if the landing pad label
encoded in `LPAD` is not zero and does not match the expected landing pad label
in bits 31:12 of the `x7` register, then a software check exception (cause=18) with
`*tval` set to "landing pad fault (code=2)" is raised else the `ELP` is updated to
`NO_LP_EXPECTED`.

[NOTE]
====
The tracking of `ELP` and the requirement for a landing pad instruction
at the target of indirect call and jump enables a processor implementation to
significantly reduce or to prevent speculation to non-landing-pad instructions.
Constraining speculation using this technique, greatly reduces the gadget space
and increases the difficulty of using techniques such as branch-target-injection,
also known as Spectre variant 2, which use speculative execution to leak data
through side channels.

The `LPAD` requires a 4-byte alignment to address the concatenation of two
instructions `A` and `B` accidentally forming an unintended landing pad in the
program. For example, consider a 32-bit instruction where the bytes 3 and 2 have
a pattern of `?017h` (for example, the immediate fields of a `lui`, `auipc`, or
a `jal` instruction), followed by a 16-bit or a 32-bit instruction. When
patterns that can accidentally form a valid landing pad are detected, the
assembler or linker can force instruction `A` to be aligned to a 4-byte
boundary to force the unintended `LPAD` pattern to become misaligned and thus
not a valid landing pad or may use an alternate register allocation to prevent
the accidental landing pad.
====

=== Zicfilp CSRs

This section specifies the CSR state of the Zicfilp extension.

==== Machine environment configuration register (`menvcfg`)

.Machine environment configuration register (`menvcfg`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'LPE'},
  {bits:  1, name: 'WPRI'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 53, name: 'WPRI'},
  {bits:  1, name: 'HADE'},
  {bits:  1, name: 'PBMTE'},
  {bits:  1, name: 'STCE'},
], config:{lanes: 4, hspace:1024}}
....

Zicfilp extension introduces the `LPE` field (bit 2) in `menvcfg`. When the
`LPE` field is set to 1 and S-mode is implemented, the Zicfilp extension is
enabled in S-mode. If `LPE` field is set to 1 and S-mode is not implemented, the
Zicfilp extension is enabled in U-mode.

When `LPE` field is 0, the Zicfilp extension is not enabled in S-mode, and the
following rules apply to S-mode:

* The hart does not update the expected landing pad (`ELP`) state, and the `ELP`
  state remains `NO_LP_EXPECTED`.
* The `LPAD` instruction operates as a no-op.

If the `LPE` field is 0 and S-mode is not implemented, these rules apply to
U-mode.

==== Supervisor environment configuration register (`senvcfg`)

.Supervisor environment configuration register (`senvcfg`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'LPE'},
  {bits:  1, name: 'WPRI'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 56, name: 'WPRI'},
], config:{lanes: 4, hspace:1024}}
....

Zicfilp extension introduces the `LPE` field (bit 2) in `senvcfg`. When the
`LPE` field is set to 1, the Zicfilp extension is enabled in VU/U-mode. When the
`LPE` field is 0, the Zicfilp extension is not enabled in VU/U-mode and the
following rules apply to VU/U-mode:

* The hart does not update the expected landing pad (`ELP`) state and the `ELP`
  state remains `NO_LP_EXPECTED`.
* The `LPAD` instruction operates as a no-op.

==== Hypervisor environment configuration register (`henvcfg`)

.Hypervisor environment configuration register (`henvcfg`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'LPE'},
  {bits:  1, name: 'WPRI'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 53, name: 'WPRI'},
  {bits:  1, name: 'HADE'},
  {bits:  1, name: 'PBMTE'},
  {bits:  1, name: 'STCE'},
], config:{lanes: 4, hspace:1024}}
....

Zicfilp extension introduces the `LPE` field (bit 2) in `henvcfg`. When the
`LPE` field is set to 1, the Zicfilp extension is enabled in VS-mode. When `LPE`
field is 0, the Zicfilp extension is not enabled in VS-mode and the following
rules apply to VS-mode:

* The hart does not update the expected landing pad (`ELP`) state and the `ELP`
  state remains `NO_LP_EXPECTED`.
* The `LPAD` instruction operates as a no-op.

==== Machine status registers (`mstatus`)

.Machine-mode status register (`mstatus`) for RV64
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'MPIE'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'MPP[1:0]'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'MPRV'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'TVM'},
  {bits:  1, name: 'TW'},
  {bits:  1, name: 'TSR'},
  {bits:  1, name: 'SPELP'},
  {bits:  8, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits:  2, name: 'SXL[1:0]'},
  {bits:  1, name: 'SBE'},
  {bits:  1, name: 'MBE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'MPELP'},
  {bits: 21, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

The Zicfilp extension introduces the `SPELP` (bit 23) and `MPELP` (bit 41)
fields that hold the previous `ELP`, and are updated as specified in
<<FORWARD_TRAPS>>. The `xPELP` fields are encoded as follows:

* 0 - `NO_LP_EXPECTED` - no landing pad instruction expected.
* 1 - `LP_EXPECTED` - a landing pad instruction is expected.

==== Supervisor status registers (`sstatus`)

.Supervisor-mode status register (`sstatus`) when `SXLEN=64`
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  8, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 29, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

Access to the `SPELP` field introduced by Zicfilp accesses the homonymous
fields of `mstatus` when `V=0` and the homonymous fields of `vsstatus`
when `V=1`.

==== Virtual supervisor status registers (`vsstatus`)

.Virtual supervisor status register (`vsstatus`) when `VSXLEN=64`
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  8, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 29, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

The Zicfilp extension introduces the `SPELP` (bit 23) field that holds the
previous `ELP`, and is updated as specified in <<FORWARD_TRAPS>>.
The `SPELP` field is encoded as follows:

* 0 - `NO_LP_EXPECTED` - no landing pad instruction expected.
* 1 - `LP_EXPECTED` - a landing pad instruction is expected.

==== Machine Security Configuration (`mseccfg`)

.Machine security configuration register (`mseccfg`) when `MXLEN=64`
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'MML'},
  {bits:  1, name: 'MMWP'},
  {bits:  1, name: 'RLB'},
  {bits:  5, name: 'WPRI'},
  {bits:  1, name: 'USEED'},
  {bits:  1, name: 'SSEED'},
  {bits:  1, name: 'MLPE'},
  {bits: 53, name: 'WPRI'},
], config:{lanes: 4, hspace:1024}}
....

The Zicfilp extension introduces the `MLPE` (bit 10) field in `mseccfg`. When
`MLPE` field is 1, Zicfilp extension is enabled in M-mode. When `MLPE` field
is 0, the Zicfilp extension is not enabled in M-mode and the following rules
apply to M-mode.

* The hart does not update the expected landing pad (`ELP`) state and the `ELP`
  state remains `NO_LP_EXPECTED`.
* The `LPAD` instruction operates as a no-op.

==== Debug Control and Status (`dcsr`)

.Debug Control and Status (`dcsr`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  2, name: 'prv'},
  {bits:  1, name: 'step'},
  {bits:  1, name: 'nmip'},
  {bits:  1, name: 'mprven'},
  {bits:  1, name: 'v'},
  {bits:  3, name: 'cause'},
  {bits:  1, name: 'stoptime'},
  {bits:  1, name: 'stopcount'},
  {bits:  1, name: 'stepie'},
  {bits:  1, name: 'ebreaku'},
  {bits:  1, name: 'ebreaks'},
  {bits:  1, name: '0'},
  {bits:  1, name: 'ebreakm'},
  {bits:  1, name: 'ebreakvu'},
  {bits:  1, name: 'ebreakvs'},
  {bits:  1, name: 'pelp'},
  {bits:  9, name: '0'},
  {bits:  4, name: 'debugver'},
], config:{lanes: 4, hspace:1024}}
....

The Zicfilp extension introduces the `pelp` (bit 18) in `dcsr`. The `pelp` field
holds the previous `ELP`, and is updated as specified in <<FORWARD_TRAPS>>. The
`pelp` field is encoded as follows:

* 0 - `NO_LP_EXPECTED` - no landing pad instruction expected.
* 1 - `LP_EXPECTED` - a landing pad instruction is expected.

[[FCIFIACT]]
=== Landing-Pad-Enabled (LPE) state

The term `xLPE` is used to determine if forward-edge CFI using landing pads
provided by the Zicfilp extension is enabled at a privilege mode.

When S-mode is implemented, it is determined as follows:

.`xLPE` determination when S-mode is implemented
[width=100%]
[%header, cols="^4,^12"]
|===
|Privilege Mode| xLPE
|  M           | `mseccfg.MLPE`
|  S or HS     | `menvcfg.LPE`
|  VS          | `henvcfg.LPE`
|  U or VU     | `senvcfg.LPE`
|===

When S-mode is not implemented, it is determined as follows:

.`xLPE` determination when S-mode is not implemented
[width=100%]
[%header, cols="^4,^12"]
|===
|Privilege Mode| xLPE
|  M           | `mseccfg.MLPE`
|  U           | `menvcfg.LPE`
|===

[NOTE]
====
The Zicfilp must be explicitly enabled for use at each privilege mode.

Programs compiled with the `LPAD` instruction continue to function correctly,
but without forward-edge CFI protection, when the Zicfilp extension is not
implemented or is not enabled.
====

[[LP_INST]]
=== Landing pad instruction

When Zicfilp is enabled, `LPAD` is the only instruction allowed to execute when
the `ELP` state is `LP_EXPECTED`. If Zicfilp is not enabled then the instruction
is a no-op. If Zicfilp is enabled, the `LPAD` instruction causes a software
error exception with `*tval` set to "landing pad fault (code=2)" if any of the
following conditions are true:

* The `pc` is not 4-byte aligned.
* The `ELP` is `LP_EXPECTED` and the `LPL` is not zero and the `LPL` does not
  match the expected landing pad label in bits 31:12 of the `x7` register.

If the instruction causes an software check exception, the `ELP` does not
change. The behavior of the trap caused by this software check exception is
specified in section <<FORWARD_TRAPS>>. If a software check exception is not
caused then the `ELP` is updated to `NO_LP_EXPECTED`.

[wavedrom, ,svg]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'AUIPC'},
  {bits:  5, name: 'rd', attr:'00000'},
  {bits: 20, name: 'LPL'},
], config:{lanes: 1, hspace:1024}}
....

The operation of the `LPAD` instruction is as follows:

.`LPAD` operation
[listing]
----
if (xLPE != 0)
    // If PC not 4-byte aligned then software integrity fault
    if pc[1:0] != 0
        Cause software check exception
    // If landing pad label not matched -> software integrity fault
    else if (inst.LPL != x7[31:12] && inst.LPL != 0 && ELP == LP_EXPECTED)
        Cause software check exception
    else
        ELP = NO_LP_EXPECTED
else
    no-op
endif
----

[[FORWARD_TRAPS]]
=== Preserving expected landing pad state on traps

A trap may need to be delivered to the same or to a higher privilege mode upon
completion of `JALR`/`C.JALR`/`C.JR`, but before the instruction at the target
of indirect call/jump was decoded, due to:

* Asynchronous interrupts.
* Synchronous exceptions with priority higher than that of an software
  error exception with `*tval` set to "landing pad fault (code=2)"
  (See Table 3.7 of Privileged Specification cite:[PRIV]).

The software check exception caused by Zicfilp has higher priority than an
illegal instruction exception but lower priority than instruction access fault.

The software check exception due to the instruction not being an `LPAD`
instruction when `ELP` is `LP_EXPECTED` or an software check exception caused by
the `LPAD` instruction itself (See <<LP_INST>>) leads to a trap being delivered
to the same or to a higher privilege mode.

In such cases, the `ELP` prior to the trap, the previous `ELP`, must be
preserved by the trap delivery such that it can be restored on a return from the
trap. To store the previous `ELP` state on trap delivery to M-mode, a `MPELP`
bit is provided in the `mstatus` CSR. To store the previous `ELP` state on trap
delivery to S/HS-mode, a `SPELP` bit is provided in the `mstatus` CSR. The
`SPELP` bit in `mstatus` can be accessed through the `sstatus` CSR. To store
the previous `ELP` state on traps to VS-mode, a `SPELP` bit is defined in the
`vsstatus` (VS-modes version of `sstatus`). To store the previous `ELP` state on
transition to Debug Mode, a `pelp` bit is defined in the `dcsr` register.

When a trap is taken into privilege mode `x`, the `xPELP` is set to `ELP` and
`ELP` is set to `NO_LP_EXPECTED`.

An `MRET` or `SRET` instruction is used to return from a trap in M-mode or
S-mode, respectively. An `xRET` instruction sets the `ELP` to `xPELP`, and sets
`xPELP` to `NO_LP_EXPECTED`.

Upon entry into Debug Mode, the `pelp` bit in `dcsr` is updated with the `ELP`
at the privilege level the hart was previously in and the `ELP` is set to
`NO_LP_EXPECTED`. When a hart resumes from Debug Mode, the `ELP` is changed to
that specified by `pelp` in `dcsr`.

[NOTE]
====
The trap handler in privilege mode `x` must save the `xPELP` bit and the `x7`
register before performing an indirect call/jump. If the privilege mode `x`
can respond to interrupts, then the trap handler should also save these values
before enabling interrupts.

The trap handler in privilege mode `x` must restore the saved `xPELP` bit and
the `x7` register before executing the `xRET` instruction to return from a
trap.
====
