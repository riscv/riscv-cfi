[[forward]]
== Forward-edge control-flow integrity

The forward-edge CFI introduces landing pad instructions that enable software to
indicate valid targets for indirect calls and indirect jumps in a program.

A landing pad instruction (`lpcll`) is defined as the instruction that must be
placed at the program locations that can be valid targets of indirect jumps or
calls.

To enforce that the target of an indirect call or indirect jump must be a valid
landing pad instruction, the hart maintains an expected landing pad (`ELP`) state
to determine if a landing pad instruction is required at the target of an
indirect call or jump. The `ELP` state can be one of:

* 0 - `NO_LP_EXPECTED`
* 1 - `LP_EXPECTED`

The Zicfisslp extension determines if an indirect call or an indirect jump must
land on landing pad, as specified in <<IND_CALL_JMP>>. If `is_lp_expected` is 1,
an indirect call or jump updates the `ELP` to `LP_EXPECTED`.

[[IND_CALL_JMP]]
.Landing pad expected determination
[source, ruby]
----
    is_indirect_call_jump = ( (JALR || C.JR || C.JALR) &&
                              (rs1 != x1) && (rs1 != x5) ) ? 1 : 0;
    is_sw_guarded_jump = ( JALR && rd == x7 && rs1 == x7 ) ? 1 : 0;
    is_lp_expected = is_indirect_call_jump & ~is_sw_guarded_jump;
----

When `ELP` is set to `LP_EXPECTED` and the next instruction in the instruction
stream is not 4-byte aligned, or is not a `lpcll`, or if the label part encoded
in the `lpcll` does not match the expected landing pad label part in bits 31:22
of the `x7` register, then an illegal-instruction exception is raised else the
the `ELP` updates to `NO_LP_EXPECTED`.

[NOTE]
====
The tracking of `ELP` and the requirement for valid landing pad instructions
at the target of indirect call and jump enables a processor implementation to
significantly reduce or to prevent speculation to non-landing-pad instructions.
Constraining speculation using this technique, greatly reduces the gadget space
and increases the difficulty of using techniques such as branch-target-injection,
also known as Spectre variant 2, which use speculative execution to leak data
through side channels.
====

When the indirect branch using `JALR` encodes both `rd` and `rs1` as `x7`, the
branch is termed a software guarded branch. Such branches do not need to land on
a landing pad and thus do not update `ELP`. Such branches must be used by a
program only when the compiler or the program has emitted code to explicitly
verify that the target held in `x7` is a valid target for that branch.

[NOTE]
====
Software guarded branches are expected to be used by compilers for generating
code for constructs like switch-cases. When using the software guarded branches,
the compiler is required to ensure it has full control on the possible jump
targets (e.g., by obtaining the targets from a read-only table in memory and
performing bounds checking on the index into the table, etc.).

While software guarded branches may be secured using such compiler generated
checks, in some cases they may be susceptible. For example, where software can
be interrupted, the `x7` register may be spilled to mutable memory by the
interrupt or signal handler. The memory location where the register is spilled
may be susceptible to modifications. Therefore, software should opt to use the
software guarded branches only where such threats are not applicable or are
mitigated.

The fact that `x7` is used for both software-guarded jumps and to hold the
landing pad labels is benign since their use is mutually exclusive.
====

By default a landing pad allows an indirect call/jump to land on any `lpcll` in
the program, which significantly reduces the number of valid targets for an
indirect call/jump. Labeling of the landing pads enables software to achieve
greater precision in pairing up indirect call/jump sites sites with valid
targets. To support labeled landing pads, the indirect call/jump sites establish
an expected landing pad label in the `x7` register. If the target of the indirect
call/jump is a valid landing pad instruction, the expected label established in
`x7` is matched with the target's label. If a mismatch is detected then the landing
pad and the label check instructions cause an illegal-instruction exception.

Each landing pad may be labeled with a label. The landing pad instruction `lpcll`
embeds a 10-bit immediate value called the first-landing-pad-label (`FLPL`). If
`FLPL` is not 0, then the instruction compares the `FLPL` to the bits 31:22 of
the `x7` register and a mismatch causes an illegal- instruction exception.

A companion instruction `lpcnl` is provided that embeds a 10-bit immediate value
called the next-landing-pad-label (`NLPL`) that is compared to the bits 21:12 of
the `x7` register and a mismatch causes an illegal-instruction exception.

[NOTE]
====
A label that is up to 10-bit wide may be constructed using a single `lui`
instruction to store the label value in bits 31:22 of the `x7` register at the
indirect call/jump site. The bits 31:22 of the label are then checked by the
`lpcll` instruction.

The `lpcll` with `FLPL` value of 0 does not perform a label check. This enables
the use of a single label mode of operation. In this mode of operation, the
indirect call/jump sites do not need to set up any labels in `x7` register as
the `lpcll` does not do any label check with `FLPL` is 0.

A label that is up to 20-bit wide may be constructed using a single `lui`
instruction to store the label value in bits 31:12 of the `x7` register at the
indirect call/jump site. The label part held in bits 31:22 of `x7` is then
checked by the `lpcll` instruction and the label part held in bits 21:12 of `x7`
is checked by the `lpcnl` instruction.

The following instruction sequence sets up a 20-bit wide expected landing pad
label as 0xAAB33 in `x7` register prior to the indirect call.

[source, ruby]
foo:
    :
    # x10 is expected to have address of function bar()
    lui x7, $0xAAB33    # setup up the expected landing pad label
    jalr %ra, %x10
    :

The following instruction sequence forms a landing pad and matches the landing
pad label to the expected label.

[source, ruby]
bar:
    lpcll $0x2AA       # Match FLPL to x7[31:22]
    lpcnl $0x333       # Match NLPL to x7[21:12]
    :                  # continue if landing pad checks succeed

Labels wider than 20-bit may be stored in `x7` by using additional instructions
(e.g., a label upto 32-bits may be stored using an additional `addi`
instruction) at the indirect call/jump site. When labels wider than 20-bit are
in use, the additional label parts held in `x7` register are shifted into bit
positions [21:12] of the `x7` register and checked using the `lpcnl`
instruction.

The following instruction sequence illustrates the same example but using a
30-bit landing pad label 0x2AACCD55.

[source, ruby]
foo:
    :
    # x10 is expected to have address of function bar()
    lui  x7, $0xAAB33    # Setup x7[31:12] of expected FLPL and NLPL
    addi x7, x7, $0x554  # Load next part of expected label in x7[11:2]
    jalr %ra, %x10
    :

[source, ruby]
bar:
    lpcll $0x2AA         # Match FLPL to x7[31:22]
    lpcnl $0x333         # Match NLPL to x7[21:12]
    c.slli x7, x7, $0xA  # shift next label part from x7[11:2] to x7[21:12]
    lpcnl $0x155         # Match NLPL to x7[21:12]
    :                    # continue if landing pad checks succeed

====

=== Forward-edge CFI Instructions

The forward-edge CFI introduces the following instructions for landing
pad operations:

* Landing pad (See <<LP_INST>>)
** `lpcll`

* Label matching (See <<LBL_MATCH>>)
** `lpcnl`

These instructions are encoded using the SYSTEM major opcode and
the `mop.rr` encodings defined by the Zimop extension.

When a Zimop encoding is not used by the Zicfisslp extension then the
instruction follows its Zimop defined behavior.

=== Forward-edge CFI enables

When privilege mode is M, the forward-edge CFI is active when `MFCFIE` is 1 in
`mseccfg` register.

When `menvcfg.CFIE` is 0, Zicfisslp is not enabled for privilege modes less than
M, and forward-edge CFI is not active at privilege levels less than M.

When `V=0` and `menvcfg.CFIE` is 1, then forward-edge CFI is active in S-mode if
`menvcfg.SFCFIE` is 1 and is active in U-mode if `mstatus.UFCFIE` is 1.

When `henvcfg.CFIE` is 0, Zicfisslp is not enabled for use when `V=1`.

When `V=1` and both `menvcfg.CFIE` and `henvcfg.CFIE` are 1, then forward-edge CFI
is active at VS-mode if `henvcfg.SFCFIE` is 1 and is active at VU-mode if
`vsstatus.UFCFIE` is 1.

The term `xFCFIE` is used to determine if forward-edge CFI is active at
privilege mode `x` and is defined as follows:

.`xFCFIE` determination
[source, ruby]
----
if ( privilege == M-mode )
    xFCFIE = mseccfg.MFCFIE
else if ( menvcfg.CFIE == 1 && V == 0 && privilege == S-mode )
    xFCFIE = menvcfg.SFCFIE
else if ( menvcfg.CFIE == 1 && V == 0 && privilege == U-mode )
    xFCFIE = mstatus.UFCFIE
else if ( menvcfg.CFIE == 1 && henvcfg.CFIE == 1 && V == 1 && privilege == S-mode )
    xFCFIE = henvcfg.SFCFIE
else if ( menvcfg.CFIE == 1 && henvcfg.CFIE == 1 && V == 1 && privilege == U-mode )
    xFCFIE = vsstatus.UFCFIE
else
    xFCFIE = 0
----

When forward-edge CFI is not active (`xFCFIE = 0`):

* The hart does not update the expected landing pad (`ELP`) state on an
  indirect call or jump, and does not require the instruction at the target of
  an indirect call or jump to be a landing pad instruction.
* The hart does not update the expected landing pad (`ELP`) when `lpcll`
  is executed.
* The instructions defined for forward-edge CFI revert to their Zimop-defined
  behavior and do not set or check landing pad labels.

[[LP_INST]]
=== Landing pad instruction

`lpcll` is the valid landing pad instruction at target of indirect jumps and
indirect calls. When a forward-edge CFI is active, the instruction causes an
illegal-instruction exception if it is not placed at a 4-byte aligned `pc`.
The `lpcll` has the landing pad label embedded in the `FLPL` field.
If `FLPL` is not 0, `lpcll` causes an illegal-instruction exception if the
`FLPL` field in the instruction does not match bits 31:22 of `x7` register.

[wavedrom, , ]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'SYSTEM'},
  {bits:  5, name: 'rd', attr:'00000'},
  {bits:  3, name: 'funct3', attr:['100']},
  {bits: 10, name: 'FLPL'},
  {bits:  7, name: '1000001', attr:['lpcll']},
], config:{lanes: 1, hspace:1024}}
....

When the instruction causes an illegal-instruction exception, the `ELP` does not
change. The behavior of the trap caused by this illegal-instruction exception is
specified in section <<FORWARD_TRAPS>>.

The operation of the `lpcll` instruction is as follows:

.`lpcll` operation
[source, ruby]
----
If xFCFIE != 0
    // If PC not 4-byte aligned then illegal-instruction
    if pc[1:0] != 0
        Cause illegal-instruction exception
    // If landing pad label not matched -> illegal-instruction
    else if (inst.FLPL != x7[31:22] && inst.FLPL != 0)
        Cause illegal-instruction exception
    else
        ELP = NO_LP_EXPECTED
else
    [rd] = 0;
endif
----

Whereas `lpcll` is the only instruction that can execute when `ELP` is
`LP_EXPECTED`, `lpcll` can also execute when `ELP` is `NO_LP_EXPECTED`.

[NOTE]
====
Concatenation of two instructions `A` and `B` can accidentally form a valid
landing pad in the program. For example, consider a 32-bit instruction where the
bytes 3 and 2 have a pattern of `4073h` or `c073h` (for example, the immediate
fields of a `lui`, `auipc`, or a `jal` instruction), followed by a 16-bit or a
32-bit instruction with a second byte with pattern of `83` (for example, an
`addi x6, x0, 1`).

The `lpcll` requires a 4-byte alignment. When patterns that can accidentaly form
a valid landing pad are detected, the assembler/linker can force instruction `A`
to be aligned to a 4-byte boundary to force the unintended `lpcll` pattern to
become misaligned and thus not a valid landing pad.
====

[[LBL_MATCH]]
=== Label matching instructions

The `lpcnl` instruction matches the 10-bit label part in its `NLPL` field with
the bits 21:12 of the `x7` register and causes an illegal-instruction exception
on a mismatch. The `lpcnl` is not a valid target for an indirect call or jump.

[wavedrom, , ]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'SYSTEM'},
  {bits:  5, name: 'rd', attr:'00000'},
  {bits:  3, name: 'funct3', attr:['100']},
  {bits: 10, name: 'NLPL'},
  {bits:  7, name: '1000011', attr:['lpcnl']},
], config:{lanes: 1, hspace:1024}}
....

The operation of the `lpcnl` instruction is as follows:

.`lpcnl` operation
[source, ruby]
----
If xFCFIE != 0
    if (x7[21:12] != inst.NLPL)
        cause illegal-instruction exception
else
    [dst] = 0;
endif
----

[[FORWARD_TRAPS]]
=== Preserving expected landing pad state on traps

A trap may need to be delivered to the same or to a higher privilege mode upon
completion of `JALR`/`C.JALR`/`C.JR`, but before the instruction at the target
of indirect call/jump was decoded, due to:

* Asynchronous interrupts.
* Synchronous exceptions with priority lower than that of an illegal-instruction
  exception (See Table 3.7 of Privileged Specification cite:[PRIV]).
* By the illegal-instruction exception due to the instruction at the target not
  being an `lpcll` instruction, or the `lpcll` instruction not being 4-byte
  aligned, or due to the `FLPL` encoded in the `lpcll` not matching the bits
  31:22 of `x7` register.

In such cases, the `ELP` prior to the trap, the previous `ELP`, may be
`LP_EXPECTED`.

To store the previous `ELP` state on trap delivery to M-mode, a `MPELP` bit
is provided in the `mstatus` CSR to hold the previous `ELP`.

To store the previous `ELP` state on trap delivery to S/HS-mode, a `SPELP`
bit is provided in the `mstatus` CSR to hold the previous `ELP`. The `SPELP`
bit in `mstatus` can be accessed through the `sstatus` CSR.

To store the previous `ELP` state on traps to VS-mode, a `SPELP` bit is
defined in the `vsstatus` (VS-modes version of `sstatus`) to hold the previous
`ELP`.

When a trap is taken into privilege mode `x`, the `xPELP` is set to `ELP` and
`ELP` is set to `NO_LP_EXPECTED`.

An `MRET` or `SRET` instruction is used to return from a trap in M-mode or
S-mode, respectively. When executing an `xRET` instruction, the `ELP` is set to
`xPELP`, and the `xPELP` is set to `NO_LP_EXPECTED`.

[NOTE]
====
The trap handler in privilege mode `x` must save the `xPELP` bit and the `lpl`
register before performing an indirect call/jump. If the privilege mode `x`
can respond to interrupts, then the trap handler should also save these values
before enabling interrupts.

The trap handler in privilege mode `x` must restore the saved `xPELP` bit and
the `lpl` register before executing the `xRET` instruction to return from a
trap.
====
