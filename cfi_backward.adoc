
[[backward]]
== Shadow Stack (Zicfiss)

The Zicfiss extension introduces a shadow stack to enforce backward-edge
control-flow integrity, A shadow stack is a second stack used to store a
shadow copy of the return address in the link register if it needs to be
spilled.

The shadow stack is designed to provide integrity to control transfers performed
using a _return_ (where the return may be from a procedure invoked using an
indirect call or a direct call), and this is referred to as backward-edge
protection.

A program using backward-edge control-flow integrity has two stacks: a regular
stack and a shadow stack. The shadow stack is used to spill the link register,
if required, by non-leaf functions. An additional register, shadow-stack-pointer
(`ssp`), is introduced in the architecture to hold the address of the top of the
active shadow stack.

The shadow stack, similar to the regular stack, grows downwards, i.e. from higher
addresses to lower addresses. Each entry on the shadow stack is `XLEN` wide and
holds the link register value. The `ssp` points to the top of the shadow stack,
i.e. address of the last element stored on the shadow stack.

The shadow stack is architecturally protected from inadvertent corruptions and
modifications, as detailed later (See <<SSMP>>).

The Zicfiss extension provides instructions to store and load the link register
to/from the shadow stack and to check the integrity of the return address. The
extension provides instructions to support common stack maintenance operations
such as stack unwinding and stack switching.

When Zicfiss is enabled, each function that needs to spill the link register
(e.g., non-leaf functions) stores the link register value to the regular stack
and a shadow copy of the link register value to the shadow stack when the
function is entered (the prologue). When such a function returns (the
epilogue), the function loads the link register from the regular stack and
the shadow copy of the link register from the shadow stack. Then, the link register
value from the regular stack and the shadow link register value from the shadow
stack are compared.  A mismatch of the two values is indicative of a subversion
of the return address control variable and causes a software-check exception.

The Zicfiss instructions are encoded using a subset of "May be op" instructions
defined by the Zimop and Zcmop extensions cite:[ZIMOP]. This subset of
instructions revert to their Zimop/Zcmop defined behavior when the Zicfiss
extension is not implemented or if the extension has not been activated at a
privilege mode. A program that is built with Zicfiss instructions can thus
continue to operate correctly, but without backward-edge control-flow integrity,
on processors that do not support the Zicfiss extension or if the Zicfiss
extension is not active. The Zicfiss extensions may be activated for use
individually and independently for each privilege mode.

Compilers should flag each object file (for example, using flags in the elf
attributes) to indicate if the object file has been compiled with the Zicfiss
instructions. The linker should flag (for example, using flags in the elf
attributes) the binary/executable generated by linking objects as being
compiled with the Zicfiss instructions only if all the object files that are
linked have the same Zicfiss attributes.

The dynamic loader should activate the use of Zicfiss extension for an
application only if all executables (the application and the dependent
dynamically linked libraries) used by that application use the Zicfiss
extension.

An application that has the Zicfiss extension active may request the dynamic
loader at runtime to load a new dynamic shared object (using dlopen() for
example). If the requested object does not have the Zicfiss attribute then
the dynamic loader, based on its policy (e.g, established by the operating
system or the administrator) configuration, could either deny the request or
deactivate the Zicfiss extension for the application. It is strongly recommended
that the policy enforces a strict security posture and denies the request.

When the Zicfiss extension is not active or not implemented, the Zicfiss
instructions revert to their Zimop/Zcmop defined behavior. This allows a
compiled with Zicfiss instructions to operate correctly but without
backward-edge control-flow integrity.

The Zicfiss extension has dependencies on the following extensions: A, Zicsr,
Zimop, and Zcmop. Additionally, use of Zicfiss in U-mode requires S-mode to be
implemented.

=== Zicfiss Instructions Summary

The Zicfiss extension introduces the following instructions:

* Push to the shadow stack (See <<SS_PUSH>>)
** `SSPUSH x1` and `SSPUSH x5` - encoded using `MOP.RR.7`
** `C.SSPUSH x1` - encoded using `C.MOP.1`

* Pop from the shadow stack (See <<SS_POP>>)
** `SSPOPCHK x1` and `SSPOPCHK x5` - encoded using `MOP.R.28`
** `C.SSPOPCHK x5` - encoded using `C.MOP.5`

* Read the value of `ssp` into a register (See <<SSP_READ>>)
** `SSRDP` - encoded using `MOP.R.28`

* Perform an atomic swap from a shadow stack location (See <<SSAMOSWAP>>)
** `SSAMOSWAP`

When a `MOP.RR.7` or `MOP.R.28` encoding is not utilized by the Zicfiss
extension, the instruction adheres to its Zimop-defined behavior, unless it is
employed by another extension. In such cases, the instruction follows the
behavior specified by that other extension.

<<<

=== Zicfiss CSRs

This section specifies the CSR state of the Zicfiss extensions.

==== Machine environment configuration register (`menvcfg`)

.Machine environment configuration register (`menvcfg`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  2, name: 'WPRI'},
  {bits:  1, name: 'SSE'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 53, name: 'WPRI'},
  {bits:  1, name: 'ADUE'},
  {bits:  1, name: 'PBMTE'},
  {bits:  1, name: 'STCE'},
], config:{lanes: 4, hspace:1024}}
....

The Zicfiss extension adds the `SSE` field (bit 3) to `menvcfg`. When the `SSE`
field is set to 1 and S-mode is implemented, the Zicfiss extension is enabled in
S-mode.

When `SSE` field is 0, the following rules apply to privilege modes that are
less than M:

* 32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.
* 16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.
* The `pte.xwr=010b` encoding in VS/S-stage page tables becomes reserved.
* The `henvcfg.SSE` and `senvcfg.SSE` fields will read as zero and are read-only.

==== Supervisor environment configuration register (`senvcfg`)

.Supervisor environment configuration register (`senvcfg`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  2, name: 'WPRI'},
  {bits:  1, name: 'SSE'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 56, name: 'WPRI'},
], config:{lanes: 4, hspace:1024}}
....

Zicfiss extension introduces the `SSE` field (bit 3) in `senvcfg`. If the
`SSE` field is set to 1, the Zicfiss extension is activated in VU/U-mode. When
the `SSE` field is 0, the Zicfiss extension remains inactive in VU/U-mode, and
the following rules apply:

* 32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.
* 16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.

==== Hypervisor environment configuration register (`henvcfg`)

.Hypervisor environment configuration register (`henvcfg`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  2, name: 'WPRI'},
  {bits:  1, name: 'SSE'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 53, name: 'WPRI'},
  {bits:  1, name: 'ADUE'},
  {bits:  1, name: 'PBMTE'},
  {bits:  1, name: 'STCE'},
], config:{lanes: 4, hspace:1024}}
....

Zicfiss extension introduces the `SSE` field (bit 3) in `henvcfg`. If the
`SSE` field is set to 1, the Zicfiss extension is activated in VS-mode. When
the `SSE` field is 0, the Zicfiss extension remains inactive in VS-mode, and
the following rules apply when `V=1`:

* 32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.
* 16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.
* The `pte.xwr=010b` encoding in VS-stage page tables becomes reserved.
* The `senvcfg.SSE` field will read as zero and is read-only.

==== Shadow stack pointer (`ssp`)

The `ssp` CSR is an unprivileged read-write (URW) CSR that reads and writes
`XLEN` low order bits of the shadow stack pointer (`ssp`). The CSR address is
0x011. There is no high CSR defined as the `ssp` is always as wide as the `XLEN`
of the current privilege mode. The bits 1:0 of `ssp` are read-only zero. If the
UXLEN or SXLEN may never be 32, then the bit 2 is also read-only zero.

Attempts to access the `ssp` CSR may result in either an illegal-instruction
exception or a virtual instruction exception, contingent upon the state of the
`__x__envcfg.SSE` fields. The conditions are specified as follows:

* If the privilege mode is less than M and `menvcfg.SSE` is 0, an
  illegal-instruction exception is raised.
* Otherwise, if in U-mode and `senvcfg.SSE` is 0, an illegal-instruction
  exception is raised.
* Otherwise, if in VS-mode and `henvcfg.SSE` is 0, a virtual instruction
  exception is raised.
* Otherwise, if in VU-mode and either `henvcfg.SSE` or `senvcfg.SSE` is 0,
  a virtual instruction exception is raised.
* Otherwise, the access is allowed.

<<<

=== Shadow-Stack-Enabled (SSE) state

The term `xSSE` is used to determine if backward-edge CFI using shadow stacks
provided by the Zicfiss extension is enabled at a privilege mode.

When S-mode is implemented, it is determined as follows:

.`xSSE` determination when S-mode is implemented
[width=100%]
[%header, cols="^4,^12"]
|===
|Privilege Mode| xSSE
|  M           | `0`
|  S or HS     | `menvcfg.SSE`
|  VS          | `henvcfg.SSE`
|  U or VU     | `senvcfg.SSE`
|===

When S-mode is not implemented, then `xSSE` is 0 at both M and U privilege modes.

[NOTE]
====
Activating Zicfiss in U-mode must be done explicitly per process. Not activating
Zicfiss at U-mode for a process when that application is not compiled with
Zicfiss allows it to invoke shared libraries that may contain Zicfiss
instructions. The Zicfiss instructions in the shared library revert to their
Zimop/Zcmop-defined behavior in this case.

When Zicfiss is enabled in S-mode it is benign to use an operating system that is
not compiled with Zicfiss instructions. Such an operating system that does
not use backward-edge CFI for S-mode execution may still activate Zicfiss for
U-mode applications.

When programs that use Zicfiss instructions are installed on a processor that
supports the Zicfiss extension but the extension is not enabled at the privilege
mode where the program executes, the program continues to function correctly but
without backward-edge CFI protection as the Zicfiss instructions will revert to
their Zimop/Zcmop-defined behavior.

When programs that use Zicfiss instructions are installed on a processor that
does not support the Zicfiss extension but supports the Zimop and Zcmop
extensions, the programs continues to function correctly but without
backward-edge CFI protection as the Zicfiss instructions will revert to their
Zimop/Zcmop-defined behavior.

On processors that do not support Zimop/Zcmop extensions, all Zimop/Zcmop code
points including those used for Zicfiss instructions may cause an
illegal-instruction exception. Execution of programs that use these
instructions on such machines is not supported.

Activating Zicfiss in M-mode is currently not supported. Additionally, when
S-mode is not implemented, activation in U-mode activation is also not
supported. These functionalities may be introduced in a future standard
extension.
====

<<<

[[SS_PUSH]]
=== Push to shadow stack
A shadow stack push operation is defined as decrement of the `ssp` by `XLEN`
followed by a write of the link register at the new top of the shadow stack.

[wavedrom, ,svg]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'SYSTEM'},
  {bits:  5, name: 'rd', attr:['00000']},
  {bits:  3, name: 'funct3', attr:['100']},
  {bits:  5, name: 'rs1', attr:['00000']},
  {bits:  5, name: 'rs2', attr:['00001', '00101']},
  {bits:  7, name: '1100111', attr:['SSPUSH x1','SSPUSH x5']},
], config:{lanes: 1, hspace:1024}}
....

[wavedrom, ,svg]
....
{reg: [
  {bits:  2, name: 'op', attr:'C1'},
  {bits:  5, name: '00000'},
  {bits:  1, name: '1'},
  {bits:  3, name: 'n[3:1]', attr:['000']},
  {bits:  1, name: '0'},
  {bits:  1, name: '0'},
  {bits:  3, name: '011', attr:['C.SSPUSH x1']},
], config:{lanes: 1, hspace:1024}}
....

Only `x1` and `x5` encodings are supported as `rs2` for `SSPUSH`. Zicfiss
provides 16-bit versions of the `SSPUSH x1` instruction using the Zcmop
defined `C.MOP.1` encoding. The `C.SSPUSH x1` expands to `SSPUSH x1`.

The `SSPUSH` instruction and its compressed form `C.SSPUSH` can be used, to push
a link register on the shadow stack. The `SSPUSH` and `C.SSPUSH` instructions
performs a store identically to the existing store instructions, with the
difference that the base is implicitly `ssp` and the width is implicitly `XLEN`.

The `SSPUSH` and `C.SSPUSH` instructions require the virtual address in `ssp` to
have a shadow stack attribute (see <<SSMP>>). Correct execution of `SSPUSH` and
`C.SSPUSH` requires that `ssp` refers to idempotent memory. If the memory
referenced by `ssp` is not idempotent, then the `SSPUSH`/`C.SSPUSH` instructions
cause a store/AMO access-fault exception. If the virtual address in `ssp` is not
`XLEN` aligned, then the `SSPUSH`/`C.SSPUSH` instructions cause a store/AMO
access-fault exception.

The operation of the `SSPUSH` and `C.SSPUSH` instructions is as follows:

.`SSPUSH` and `C.SSPUSH` operation
[listing]
----
if (xSSE == 1)
    mem[ssp - (XLEN/8)] = X(src)  # Store src value to ssp - XLEN/8
    ssp = ssp - (XLEN/8)          # decrement ssp by XLEN/8
endif
----

The `ssp` is decremented by `SSPUSH` and `C.SSPUSH` only if the store to the
shadow stack completes successfully.

[[SS_POP]]
=== Pop from the shadow stack

A shadow stack pop operation is defined as a `XLEN` wide read from the
current top of the shadow stack followed by an increment of the `ssp` by
`XLEN`.

[wavedrom, ,svg]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'SYSTEM'},
  {bits:  5, name: 'rd',  attr:['00000','00000']},
  {bits:  3, name: 'funct3', attr:['100']},
  {bits:  5, name: 'rs1', attr:['00001','00101']},
  {bits: 12, name: '110011011100', attr:['SSPOPCHK x1','SSPOPCHK x5']},
], config:{lanes: 1, hspace:1024}}
....

[wavedrom, ,svg]
....
{reg: [
  {bits:  2, name: 'op', attr:'C1'},
  {bits:  5, name: '00000'},
  {bits:  1, name: '1'},
  {bits:  3, name: 'n[3:1]', attr:['010']},
  {bits:  1, name: '0'},
  {bits:  1, name: '0'},
  {bits:  3, name: '011', attr:['C.SSPOPCHK x5']},
], config:{lanes: 1, hspace:1024}}
....

Only `x1` and `x5` encodings are supported as `rs1` for `SSPOPCHK`. Zicfiss
provides a 16-bit version of the `SSPOPCHK x5` using Zcmop define `C.MOP.5`
encoding. The `C.SSPOPCHK x5` expands to `SSPOPCHK x5`.

Usually programs with a shadow stack push the return address onto the regular
stack as well as the shadow stack in the function prologue of non-leaf
functions. Such programs when returning from the non-leaf function pop the link
register from the regular stack and pop a shadow copy of the link register from
the shadow stack. The two values are then compared. If the values do not match
it is indicative of a corruption of the return address variable on the regular
stack.

The `SSPOPCHK` instruction and its compressed form `C.SSPOPCHK` can be used to
pop the shadow return address value from the shadow stack and check that the
value matches the contents of the link register and if not cause a
software-check exception with `__x__tval` set to "shadow stack fault (code=3)".

While any register may be used as link register, conventionally the `x1` or `x5`
registers are used. The shadow stack instructions are designed to be most
efficient when the `x1` and `x5` registers are used as the link register.

[NOTE]
====
Return-address prediction stacks are a common feature of high-performance
instruction-fetch units, but they require accurate detection of instructions
used for procedure calls and returns to be effective. For RISC-V, hints as to
the instructions usage are encoded implicitly via the register numbers used.
The return-address stack (RAS) actions to pop and/or push onto the RAS are
specified in Table 2.1 of the Unprivileged specification cite:[UNPRIV].

Using `x1` or `x5` as the link register allows a program to benefit from the
return-address prediction stacks. Additionally, since the shadow stack
instructions are designed around the use of `x1` or `x5` as the link register,
using any other register as a link register would incur the cost of additional
register movements.

Compilers when generating code with backward-edge CFI must protect the link
register, e.g. `x1` and/or `x5`, from arbitrary modification by not emitting
unsafe code sequences.
====

[NOTE]
====
When shadow stack is active, programs store the return addresses on both the
regular stack and the shadow stack in the function prologue, and then pop them
them from both stacks and compare the values before returning from the function.
Storing the return address on both stacks preserves the call stack layout and
the ABI, while also allowing for the detection of corruption of the return
address on the regular stack.

The prologue and epilogue of a non-leaf function that uses shadow stacks is as
follows:

[listing]
----
    function_entry:
        addi sp,sp,-8  # push link register x1
        sd x1,(sp)     # on data stack
        sspush x1      # push link register x1 on shadow stack
         :
         :
        ld x1,(sp)     # pop link register x1 from data stack
        addi sp,sp,8
        sspopchk x1    # compare link register x1 to shadow
                       # return address; faults if not same
        ret
----

This example illustrate the use of `x1` register as the link register.
Alternatively, the `x5` register may also be used as the link register.

A leaf function (i.e., a function that does not itself make function calls) does
not need to spill the link register and the return value may be held in the link
register itself for the duration of the leaf functions execution.
====

The `C.SSPOPCHK`, and `SSPOPCHK` instructions perform a load identically to the
existing load instructions, with the difference that the base is implicitly
`ssp` and the width is implicitly `XLEN`.

The `SSPOPCHK` and `C.SSPOPCHK` instructions require the virtual address in
`ssp` to have a shadow stack attribute (see <<SSMP>>). Correct execution of
`SSPOPCHK` and `C.SSPOPCHK` requires that `ssp` refers to idempotent memory. If
the memory reference by `ssp` is not idempotent, then the instructions cause a
load access-fault exception. If the virtual address in `ssp` is not `XLEN`
aligned, then `SSPOPCHK` and `C.SSPOPCHK` instructions cause a load
access-fault exception

[NOTE]
====
Misaligned accesses to shadow stack are not required and enforcing alignment is
more secure to detect errors in the program. An access-fault exception is raised
instead of address-misaligned exception in such cases to indicate fatality and
that the instruction must not be emulated by a trap handler.

The `SSPOPCHK` instruction performs a load followed by a check of the loaded
data value with the link register as source. If the check against the link register
faults, and the instruction is restarted by the trap handler, then the instruction
will perform a load again. If the memory from which the load is performed is
non-idempotent, then the second load may cause unexpected side effects.
Instructions that load from the shadow stack require the memory referenced by
`ssp` to be idempotent to avoid such concerns. Locating shadow stacks in
non-idempotent memory, such as non-idempotent device memory, is not an expected
usage, and requiring memory referenced by `ssp` to be idempotent does not pose a
significant restriction.
====

The operation of the `SSPOPCHK` and `C.SSPOPCHK` instructions is as follows:

.`SSPOPCHK` and `C.SSPOPCHK` operation
[listing]
----
if (xSSE == 1)
    temp = mem[ssp]            # Load temp from address in ssp and
    if temp != X(src)          # Compare temp to value in src and
                               # cause an software-check exception
                               # if they are not bitwise equal.
                               # Only x1 and x5 may be used as src
       Raise software-check exception
    else
       ssp = ssp + (XLEN/8)    # increment ssp by XLEN/8.
    endif
endif
----

If the value loaded from the address in `ssp` does not match the value in `rs1`,
a software-check exception (cause=18) is raised with `__x__tval` set to "shadow
stack fault (code=3)". The software-check exception caused by `SSPOPCHK`/
`C.SSPOPCHK` is lower in priority than a load access-fault exception.

The `ssp` is incremented by `SSPOPCHK` and `C.SSPOPCHK` only if the load from
the shadow stack completes successfully and no software-check exception is
raised.

[NOTE]
====
The use of the compressed instruction `C.SSPUSH x1` to push on the shadow stack
is most efficient when the ABI uses `x1` as the link register, as the link
register may then be pushed without needing a register-to-register move in the
function prologue. To use the compressed instruction `C.SSPOPCHK x5`, the
function should pop the return address from regular stack into the alternate
link register `x5` and use the `C.SSPOPCHK x5` to compare the return address to
the shadow copy stored on the shadow stack. The function then uses `C.JR x5` to
jump to the return address.

[listing]
----
    function_entry:
        c.addi sp,sp,-8  # push link register x1
        c.sd x1,(sp)     # on data stack
        c.sspush x1      # push link register x1 on shadow stack
         :
         :
        c.ld x5,(sp)     # pop link register x5 from data stack
        c.addi sp,sp,8
        c.sspopchk x5    # compare link register x5 to shadow
                         # return address; faults if not same
        c.jr x5
----

====

[NOTE]
====
Store-to-load forwarding is a common technique employed by high-performance
processor implementations. Zicfiss implementations may prevent forwarding from
a non-shadow-stack store to the `SSPOPCHK` or the `C.SSPOPCHK` instructions. A
non-shadow-stack store causes a fault if done to a page mapped as a shadow
stack. However, such determination may be delayed till the PTE has been examined
and thus may be used to transiently forward the data from such stores to
`SSPOPCHK` or to `C.SSPOPCHK`.
====

[[SSP_READ]]
=== Read `ssp` into a register

The `SSRDP` instruction is provided to move the contents of `ssp` to a destination
register.

[wavedrom, ,svg]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'SYSTEM'},
  {bits:  5, name: 'rd', attr:['dst']},
  {bits:  3, name: 'funct3', attr:['100']},
  {bits:  5, name: '00000'},
  {bits: 12, name: '110011011100', attr:['SSRDP']},
], config:{lanes: 1, hspace:1024}}
....

Encoding `rd` as `x0` is not supported for `SSRDP`.

The operation of the `SSRDP` instructions is as follows:

.`SSRDP` operation
[listing]
----
if (xSSE == 1)
    X(dst) = ssp
else
    X(dst) = 0
endif
----

[NOTE]
====
The property of Zimop writing 0 to the `rd` when the extension using Zimop is
not implemented, enabled for use, or not enabled may be used by to determine if
Zicfiss extension is enabled. For example, functions that unwind shadow stacks
may skip over the unwind actions by dynamically detecting if the Zicfiss
extension is enabled.

An example sequence such as the following may be used:

[listing]
    ssrdp t0                      # mv ssp to t0
    beqz t0, zicfiss_not_enabled  # zero is not a valid shadow stack
                                  # pointer by convention
    # Zicfiss is enabled
    :
    :
zicfiss_not_active:

Operating systems and runtimes must not locate shadow stacks at address 0 to
assist with the use of such code sequences.
====

[NOTE]
====
A common operation performed on stacks is to unwind them to support constructs
like `setjmp`/`longjmp`, C++ exception handling, etc. A program that uses shadow
stacks must unwind the shadow stack in addition to the stack used to store data.
The unwind function must verify that it does not accidentally unwind past the
bounds of the shadow stack. Shadow stacks are expected to be bounded on each end
using guard pages, i.e. pages that do not have a shadow stack attribute. To
detect if the unwind occurs past the bounds of the shadow stack, the unwind may
be done in maximal increments of 4 KiB and testing for the `ssp` to be still
pointing to a shadow stack page or has unwound into the guard page. The
following examples illustrate the use of shadow stack instructions to
unwind a shadow stack. This example assumes that the `setjmp` function itself does
not push on to the shadow stack (being a leaf function, it is not required to).

[listing]
setjmp() {
    :
    :
    // read and save the shadow stack pointer to jmp_buf
    asm("ssrdp %0" : "=r"(cur_ssp):);
    jmp_buf->saved_ssp = cur_ssp;
    :
    :
}
longjmp() {
    :
    // Read current shadow stack pointer and
    // compute number of call frames to unwind
    asm("ssrdp %0" : "=r"(cur_ssp):);
    // Skip the unwind if backward-edge CFI not enabled
    asm("beqz %0, back_cfi_not_enabled" : "=r"(cur_ssp):);
    // Unwind the frames in a loop
    while ( jmp_buf->saved_ssp > cur_ssp ) {
        // advance by a maximum of 4K at a time to avoid
        // unwinding past bounds of the shadow stack
        cur_ssp = ( (jmp_buf->saved_ssp - cur_ssp) >= 4096 ) ?
                  (cur_ssp + 4096) : jmp_buf->saved_ssp;
        asm("csrw ssp, %0" : :  "r" (cur_ssp));
        // Test if unwound past the shadow stack bounds
        asm("sspush x5");
        asm("sspopchk x5");
    }
back_cfi_not_enabled:
    :
}
====

[[SSAMOSWAP]]
=== Atomic Swap from a shadow stack location

The `SSAMOSWAP` instruction performs an atomic swap operation between the XLEN
bits of the `src` register and the XLEN bits located on the shadow stack at the
address specified in the `addr` register.  The resulting value from the swap
operation is then stored into the register specified in the `dst` operand.

[wavedrom, , ]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'AMO'},
  {bits:  5, name: 'rd', attr:'dest'},
  {bits:  3, name: 'funct3', attr:['010', '011']},
  {bits:  5, name: 'rs1', attr:'addr'},
  {bits:  5, name: 'rs2', attr:'src'},
  {bits:  1, name: 'rl'},
  {bits:  1, name: 'aq'},
  {bits:  5, name: '00101', attr:['SSAMOSWAP.W', 'SSAMOSWAP.D']},
], config:{lanes: 1, hspace:1024}}
....

The `SSAMOSWAP` instruction requires the virtual address in `addr` to have a
shadow stack attribute (see <<SSMP>>). If the virtual address is not XLEN
aligned, then `SSAMOSWAP` causes a store/AMO access-fault exception. If the
memory reference by the `ssp` is not idempotent, then `SSAMOSWAP` causes a
store/AMO access-fault exception. The operation of the `SSAMOSWAP` instructions
is as follows:

.`SSAMOSWAP` operation
[listing]
----
  if privilege_mode != M && menvcfg.SSE == 0
      raise illegal-instruction exception
  else if privilege_mode == U && senvcfg.SSE == 0
      raise illegal-instruction exception
  else if privilege_mode == VS && henvcfg.SSE == 0
      raise virtual instruction exception
  else if privilege_mode == VU && senvcfg.SSE == 0
      raise virtual instruction exception
  else
      X(rd) = mem[X(rs1)]
      mem[X(rs1)] = X(rs2)
  endif
----

Just as for AMOs in the A extension, `SSAMOSWAP` requires that the address
held in `rs1` be naturally aligned to the size of the operand (i.e., 16-byte
aligned for __quadwords__, eight-byte aligned for __doublewords__, and four-byte
aligned for __words__). And the same exception options apply if the address is
not naturally aligned.

Just as for AMOs in the A extension, the `SSAMOSWAP` optionally provide release
consistency semantics, using the `aq` and `rl` bits, to help implement
multiprocessor synchronization. The memory operation performed by an
`SSAMOSWAP`, has acquire semantics if `aq` bit is 1 and has release semantics if
`rl` bit is 1.

[NOTE]
====
Stack switching is a common operation in user programs as well as supervisor
programs. When a stack switch is performed the stack pointer of the currently
active stack is saved into a context data structure and the new stack is made
active by loading a new stack pointer from a context data structure.

When shadow stacks are active for a program, the program needs to additionally
switch the shadow stack pointer. If the pointer to the top of the deactivated
shadow stack is held in a context data structure, then it  may be susceptible to
memory corruption vulnerabilities. To protect the pointer value, the program may
store it at the top of the deactivated shadow stack itself and thereby create a
checkpoint.

An example sequence to restore the shadow stack pointer from the new shadow
stack and save the old shadow stack pointer on the old shadow stack is as
follows:

[listing]
----
# a0 hold pointer to top of new shadow stack to switch to
stack_switch:
   ssrdp ra
   beqz ra, 2f                  # skip if Zicfiss not active
   ssamoswap ra, x0,  (a0)      # ra=*[a0] and *[a0]=0
   beq       ra, a0,  1f        # [a0] must be == [ra]
   unimp                        # else crash
1: addi      ra, ra,  XLEN/8    # pop the checkpoint
   csrrw     ra, ssp, ra        # swap ssp: ra=ssp, ssp=ra
   addi      ra, ra,  -(XLEN/8) # checkpoint = "old ssp - XLEN/8"
   ssamoswap x0, ra,  (ra)      # Save checkpoint at "old ssp - XLEN/8" 
2:
----

A legal checkpoint is defined as one that holds a value of `X`, where `X` is the
address at which the checkpoint is positioned on the shadow stack.

The sequence uses the `ra` register. If the privilege mode at which this
sequence is executed can be interrupted then the trap handler should save the
`ra` on the shadow stack itself, where it is guarded against tampering and
restore it prior to returning from the trap.

When a new shadow stack is created by the supervisor, it needs to store a
checkpoint at the highest address on that stack. This enables the shadow stack
pointer to be switched using the process outlined in this note. The `SSAMOSWAP`
instruction can be used to store this checkpoint. When the old value at the
memory location operated on by `SSAMOSWAP` is not required, `rd` can be set to
`x0`.
====

[[SSMP]]
=== Shadow Stack Memory Protection

To protect shadow stack memory the memory is associated with a new page type -
Shadow Stack (SS) page - in the page tables.

==== Virtual-Memory system extension for Shadow Stack

The shadow stack memory is protected using page table attributes such that it
cannot be stored to by instructions other than `SSAMOSWAP`, `SSPUSH`, and
`C.SSPUSH`. The `SSPOPCHK` and `C.SSPOPCHK` instructions can only load from
shadow stack memory.

The `SSAMOSWAP`, `SSPUSH`, and `C.SSPUSH` instructions perform a store. The
`SSPOPCHK` and `C.SSPOPCHK` instructions perform a load.

When the value of `satp.MODE` (or `vsatp.MODE` when `V=1`) is set to `Bare`
and the effective privilege mode is less than M, shadow stack memory accesses
are disallowed. Under these conditions:
* The `SSPUSH`, `SSAMOSWAP`, and `C.SSPUSH` instructions will result in a
  store/AMO access-fault exception.
* The `SSPOPCHK` and `C.SSPOPCHK` instructions will result in a load
  access-fault exception.

The `SSAMOSWAP` instruction will result in a store/AMO access-fault exception
if the effective privilege mode of its memory access is M.

Implicit accesses, including an instruction fetch, to the shadow stack page are
not allowed. Such memory accesses cause an access-fault exception corresponding
to the original access type.

The shadow stack can be read using all instructions that load from memory.

The encoding `R=0`, `W=1`, and `X=0`, is defined to represent a shadow stack
page.  When `menvcfg.SSE=0`, this encoding remains reserved. When `V=1` and
`henvcfg.SSE=0`, this encoding remains reserved at `VS` and `VU`.

The following faults may occur:

. If the accessed page is a shadow stack page:
.. Stores other than `SSAMOSWAP`, `SSPUSH`, and `C.SSPUSH` cause store/AMO
   access-fault exception.
.. Implicit accesses cause an access-fault exception corresponding to the
   original access type.
. If the accessed page is not a shadow stack page or if the page is in
  non-idempotent memory:
.. `SSAMOSWAP`, `C.SSPUSH`, and `SSPUSH` cause a store/AMO access-fault.
.. `C.SSPOPCHK` and `SSPOPCHK` cause a load access-fault.

[NOTE]
====
Stores to shadow stack by instructions other than `SSAMOSWAP`, `SSPUSH`, and
`C.SSPUSH` cause a store/AMO access-fault exception, rather than a store/AMO
page-fault exception, to indicate fatality.

If a store/AMO page fault was triggered, it would suggest that the operating
system should service that fault and correct the condition. Correcting the
condition is not possible in this case. The page fault handler would have to
resort to decoding the opcode of the instruction that caused the page fault to
determine if it was caused by non-shadow-stack-stores to shadow stack pages
(which is a fatal condition) vs. a page fault caused by an `SSAMOSWAP, `SSPUSH`
or `C.SSPUSH` to a non-resident page (which is a recoverable condition). Since
the operating system page fault handler is typically performance-critical,
causing an access-fault instead of a page fault enables the operating system to
easily distinguish between the fatal/non-recoverable conditions and recoverable
page faults.

On implementations where address-misaligned exception is prioritized higher than
access-fault exception, a trap handler handler that emulates misaligned stores
must cause an access-fault exception if store is being made to a shadow stack
page.

Shadow stack instructions cause an access-fault if the accessed page is not a
shadow stack page or if the page is in non-idempotent memory to similarly
indicate fatality.

While the specification mandates that an access-fault exception shall be
generated when either single-stage or VS-stage address translation is invoked
for an implicit access targeting a shadow stack page, it is pertinent to
highlight that, at the time of this specification's drafting, instruction
fetches are the exclusive class of implicit accesses that are subjected to
either single-stage or VS-stage address translation.
====

To support these rules, the virtual address translation process specified in
section 4.3.2 of the Privileged Specification cite:[PRIV] is modified as
follows:
[start=3]
3. If `pte.v = 0` or if any bits of encodings that are reserved for future
   standard use are set within `pte`, stop and raise a page-fault exception
   corresponding to the original access type. The encoding `pte.xwr = 010b`
   is not reserved if `V=0` and `menvcfg.SSE` is 1 or if `V=1` and
   `henvcfg.SSE` is 1.

4. Otherwise, the PTE is valid. If `pte.r = 1` or `pte.w = 1` or `pte.x = 1`,
   go to step 5. Otherwise, this PTE is a pointer to the next level of the page
   table. Let `i = i - 1`. If `i < 0`, store and raise a page-fault exception
   corresponding to the original access type. Otherwise, let `a = pte.ppn x
   PAGESIZE` and go to step 2.

5. A leaf PTE has been found. If the memory access is by a shadow stack
   instruction and `pte.xwr != 010b`, then cause an access-fault exception
   corresponding to the access type. If the memory access is either a
   non-shadow-stack store/AMO or an implicit access, and `pte.xwr == 010b`, then
   an access-fault exception is raised, corresponding to the original access type.
   If the requested memory access is not allowed by the `pte.r`, `pte.w`, `pte.x`,
   and `pte.u` bits, given the current privilege mode and the value of the `SUM`
   and `MXR` fields of the `mstatus` register, stop and raise a page-fault
   exception corresponding to the original access type.

The PMA checks are extended to require memory referenced by `SSAMOSWAP`, `SSPUSH`,
`C.SSPUSH`, `C.SSPOPCHK`, and `SSPOPCHK` to be idempotent.

The `U` and `SUM` bit enforcement is performed normally for shadow stack
instruction initiated memory accesses. The state of the `MXR` bit does not
affect read access to a shadow stack page as the shadow stack page is always
readable by all instructions that load from memory.

Svpbmt and Svnapot extensions are supported for shadow stack pages.

[NOTE]
====
All instructions that load from memory are allowed to read the shadow stack. The
shadow stack only holds a copy of the link register as saved on the regular
stack. The ability to read the shadow stack is useful for debugging, performance
profiling, and other use cases.

Operating systems should protect against writable non-shadow-stack alias
virtual-addresses mappings being created to the physical memory of the
shadow stack.

Shadow stacks are expected to be bounded on each end using guard pages, so that
no two shadow stacks are adjacent to each other. This guards against accidentally
underflowing or overflowing from one shadow stack to another. Traditionally,
a guard page for a stack is a page that is inaccessible to the process owning
the stack. For shadow stacks, the guard page may also be a non-shadow-stack
page that is otherwise accessible to the process owning the shadow stack
because shadow stack loads and stores to non-shadow-stack pages cause an
access-fault exception.
====

The G-stage address translation and protections remain unaffected by Zicfiss
extension. When G-stage page tables are active, the `C.SSPOPCHK` and `SSPOPCHK`
instructions require the G-stage page table to have read permission for the
accessed memory, whereas the `SSAMOSWAP`, `C.SSPUSH` and `SSPUSH` instructions
require write permission. The `xwr == 010b` encoding in the G-stage PTE remains
reserved.

[NOTE]
====
A future extension may define a shadow stack encoding in the G-stage page table
to support use cases such as a hypervisor enforcing shadow stack protections for
its guests.
====

==== PMP extension for shadow stack

Attempts by `SSAMOSWAP`, `SSPUSH` and `C.SSPUSH` to a PMP region that does not
have write permission raises a store access-fault exception. Attempts by
`C.SSPOPCHK` and `SSPOPCHK` to access a PMP region that does not have read
permission raises a load access-fault exception.

